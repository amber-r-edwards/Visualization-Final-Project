{% extends "base.html" %}

{% block title %}Text Reuse Network - Feminist Zine Text Reuse Analysis{% endblock %}

{% block content %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="{{ url_for('static', filename='js/publication-colors.js') }}"></script>

<style>
    .container {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    h1 {
        color: #333;
        border-bottom: 3px solid #007bff;
        padding-bottom: 10px;
    }
    .publication-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 5px;
    }
        .d3-network-container {
            width: 100%;
            height: 700px;
            margin: 20px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            position: relative;
        }
        .d3-controls {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .d3-controls label {
            margin-right: 15px;
            font-weight: bold;
        }
        .d3-controls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        .d3-controls select {
            margin: 0 10px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .d3-controls span {
            font-weight: normal;
            color: #666;
        }
        .d3-controls button {
            margin-left: 15px;
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .d3-controls button:hover {
            background-color: #0056b3;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 8px;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 0px;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            z-index: 1000;
        }
        .node {
            stroke-width: 2px;
            cursor: pointer;
        }
        .link {
            stroke-opacity: 0.6;
        }
        .legend {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        .legend-section {
            margin-bottom: 15px;
        }
        .legend-item {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 8px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }
        .publication-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Feminist Zine Text Reuse Network Visualization</h1>
        <p>Interactive network visualization showing text reuse patterns among feminist publications from 1970-1975</p>
        
        <div id="loading" style="text-align: center; padding: 2rem; color: #666;">
            Loading network data...
        </div>

        <h2>Page-Level Network</h2>
        <div class="d3-controls">
            <label>Filter by Reuse Type:
                <select id="reuse-type-filter">
                    <option value="all">All Types</option>
                    <option value="minimal_reuse">Minimal Reuse</option>
                    <option value="partial_reuse">Partial Reuse</option>
                    <option value="moderate_reuse">Moderate Reuse</option>
                </select>
            </label>
            <label>Filter by Publication:
                <select id="publication-filter">
                    <option value="all">All Publications</option>
                </select>
            </label>
            <button id="reset-zoom">Reset Zoom</button>
        </div>
        <div id="d3-network" class="d3-network-container"></div>
        
        <div class="legend">
            <div class="legend-section">
                <h3>Reuse Types (Edge Colors)</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #95a5a6;"></div>
                    <span>Minimal Reuse</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f39c12;"></div>
                    <span>Partial Reuse</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                    <span>Moderate Reuse</span>
                </div>
            </div>
            
            <div class="legend-section">
                <h3>Publications (Node Colors)</h3>
                <div id="publication-legend" class="publication-legend">
                    <!-- Publication colors will be populated by JavaScript -->
                </div>
            </div>
            
            <p><strong>Nodes:</strong> Individual page IDs | <strong>Node size:</strong> Number of connections | <strong>Edge thickness:</strong> Similarity strength</p>
        </div>
    </div>

    <script>
        // Global variables
        let globalReuseData = null;
        let globalMetadata = null;
        let networkSvg = null;
        let simulation = null;
        let pubLookupById = {}; // Add this line for pub_id linking
        
        // Helper function for reuse type colors using publication-colors.js
        function getReuseTypeColor(reuseType) {
            return reuseTypeColorManager.getColor(reuseType);
        }

        // Function to populate publication legend using only visible publications
        function populatePublicationLegend() {
            const publicationLegendContainer = document.getElementById('publication-legend');
            if (!publicationLegendContainer || !globalReuseData) return;

            publicationLegendContainer.innerHTML = '';

            // Get currently filtered data to see what publications are actually visible
            const filteredReuse = applyCurrentFilters(globalReuseData);
    
            // Get unique publications that are in the current filtered reuse data
            const visiblePublications = [...new Set([
                ...filteredReuse.map(d => d.source_publication),
                ...filteredReuse.map(d => d.target_publication)
            ].filter(Boolean))].sort();

            console.log('Publications visible in current network filter:', visiblePublications);

            // Show only the publications that are visible in the filtered data
            visiblePublications.forEach(pubName => {
                // Get pub_id for this publication name
                let pubId = null;
                for (const [pageId, pageInfo] of Object.entries(pubLookupById)) {
                    if (pageInfo.publication_name === pubName) {
                        pubId = pageInfo.pub_id;
                        break;
                    }
                }

                // Get color using pub_id
                const color = pubId ? publicationColorManager.getColorById(pubId) : publicationColorManager.getColor(pubName);

                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <span class="legend-color" style="background-color: ${color}"></span>
                    <span class="legend-label">${pubName}</span>
                `;
                publicationLegendContainer.appendChild(legendItem);
            });

            if (visiblePublications.length === 0) {
                publicationLegendContainer.innerHTML = '<div style="color: #666; font-style: italic;">No publications in current filter</div>';
            }
        }

        // Main data loading - Updated to use CSV files directly
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, starting direct CSV data load...');
        
            // Load CSV files directly from static/data/
            Promise.all([
                d3.csv("{{ url_for('static', filename='data/text_reuse_ngrams_windowed_parallel_filtered.csv') }}"),
                d3.csv("{{ url_for('static', filename='data/zinepage_metadata.csv') }}"),
                d3.csv("{{ url_for('static', filename='data/zinepub_metadata.csv') }}")
            ]).then(function([reuseData, pageMetadata, pubMetadata]) {
                console.log('Raw CSV data loaded:');
                console.log('- Reuse data:', reuseData.length, 'records');
                console.log('- Page metadata:', pageMetadata.length, 'records');
                console.log('- Publication metadata:', pubMetadata.length, 'records');
            
                if (!reuseData || reuseData.length === 0) {
                    throw new Error('No reuse data found in CSV');
                }
            
                // Process the data using pub_id linking
                // 1. Create publication lookup using pub_id
                pubLookupById = {};
                pageMetadata.forEach(page => {
                    pubLookupById[page.page_id] = {
                        publication_name: page.publication_name,
                        pub_id: page.pub_id
                    };
                });

                // 2. Create publication metadata lookup by pub_id
                const pubMetadataLookup = {};
                pubMetadata.forEach(pub => {
                    pubMetadataLookup[pub.pub_id] = pub;
                });

                // 3. Process reuse data
                const processedReuseData = reuseData.map(d => {
                    const sourcePageInfo = pubLookupById[d.source_page_id];
                    const targetPageInfo = pubLookupById[d.target_page_id];
                
                    const sourcePub = sourcePageInfo ? sourcePageInfo.publication_name : 'Unknown';
                    const targetPub = targetPageInfo ? targetPageInfo.publication_name : 'Unknown';
                
                    // Determine reuse type based on similarity score
                    const similarity = +d.combined_similarity;
                    let reuseType;
                    if (similarity < 0.3) {
                        reuseType = 'minimal_reuse';
                    } else if (similarity < 0.7) {
                        reuseType = 'partial_reuse';
                    } else {
                        reuseType = 'moderate_reuse';
                    }
                
                    return {
                        source_page_id: d.source_page_id,
                        target_page_id: d.target_page_id,
                        combined_similarity: +d.combined_similarity,
                        ngram_similarity: +(d.ngram_similarity || 0),
                        shingle_similarity: +(d.shingle_similarity || 0),
                        source_publication: sourcePub,
                        target_publication: targetPub,
                        source_date: d.source_date || '',
                        target_date: d.target_date || '',
                        reuse_type: reuseType,
                        shared_content: d.shared_content || ''
                    };
                });

                // 4. Combine metadata using pub_id
                const combinedMetadata = pageMetadata.map(page => {
                    const pubData = pubMetadataLookup[page.pub_id] || {};
                
                    return {
                        page_id: page.page_id,
                        pub_id: page.pub_id,
                        publication_name: page.publication_name,
                        volume: page.volume || '',
                        number: page.number || '',
                        page_number: page.page_number || '',
                        organization: pubData.organization || '',
                        location: pubData.location || '',
                        region: pubData.region || '',
                        notes: pubData.notes || ''
                    };
                });

                // Store globally
                globalReuseData = processedReuseData;
                globalMetadata = combinedMetadata;

                // Hide loading, show controls
                document.getElementById('loading').style.display = 'none';
                document.querySelector('.d3-controls').style.display = 'block';

                // Initialize the network
                createD3PageNetwork(processedReuseData);
                setupControls();
                populatePublicationLegend();

            }).catch(function(error) {
                console.error("Error loading CSV data:", error);
                document.getElementById('loading').innerHTML = 
                    `<div style="color: red; padding: 20px; background: #ffebee; border: 1px solid #f44336; border-radius: 5px;">
                        <h3>Error Loading Data</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p>Make sure these CSV files exist in your static/data/ folder:</p>
                        <ul>
                            <li>text_reuse_ngrams_windowed_parallel_filtered.csv</li>
                            <li>zinepage_metadata.csv</li>
                            <li>zinepub_metadata.csv</li>
                        </ul>
                    </div>`;
            });
        });

    // Updated network creation function
    function createD3PageNetwork(reuse_data, maxLinksPerNode = 20) {
        // Clear previous network
        d3.select("#d3-network").selectAll("*").remove();

        console.log(`Using reuse data: ${reuse_data.length} matches`);
        
        // Apply filters (remove similarity threshold)
        let filteredReuse = applyCurrentFilters(reuse_data);

        // Create nodes from unique page IDs
        const connectedPageIds = new Set([
            ...filteredReuse.map(d => d.source_page_id),
            ...filteredReuse.map(d => d.target_page_id)
        ]);
        
        const nodes = Array.from(connectedPageIds).map(pageId => {
            const match = filteredReuse.find(d => d.source_page_id === pageId || d.target_page_id === pageId);
            const publication = match?.source_page_id === pageId ? 
                match.source_publication : match.target_publication;
            
            // Get pub_id for color
            const pageInfo = pubLookupById[pageId];
            const pubId = pageInfo ? pageInfo.pub_id : null;
            const color = pubId ? publicationColorManager.getColorById(pubId) : publicationColorManager.getColor(publication);
            
            return {
                id: pageId,
                publication: publication,
                pub_id: pubId,
                color: color,
                linkCount: 0,
                size: 8
            };
        });
        
        // Create node lookup
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        
        // Count links per node and create links array
        const linkCounts = {};
        const links = [];
        
        filteredReuse.forEach(match => {
            const sourceId = match.source_page_id;
            const targetId = match.target_page_id;
            const similarity = match.combined_similarity;
            
            // Count links
            linkCounts[sourceId] = (linkCounts[sourceId] || 0) + 1;
            linkCounts[targetId] = (linkCounts[targetId] || 0) + 1;
            
            // Only add link if both nodes exist and haven't exceeded max links
            if (nodeMap.has(sourceId) && nodeMap.has(targetId) &&
                (linkCounts[sourceId] || 0) <= maxLinksPerNode &&
                (linkCounts[targetId] || 0) <= maxLinksPerNode) {
                
                // Determine link color and style based on publication relationship
                const sourceNode = nodeMap.get(sourceId);
                const targetNode = nodeMap.get(targetId);
                let linkColor = '#999'; // Default gray
                let linkOpacity = 0.6;
                let isDashed = false;
                
                if (sourceNode.publication === targetNode.publication) {
                    // Same publication - use publication color but lighter
                    linkColor = sourceNode.color;
                    linkOpacity = 0.3;
                } else {
                    // Different publications - use reuse type color and dashed
                    linkColor = getReuseTypeColor(match.reuse_type);
                    linkOpacity = 0.8;
                    isDashed = true;
                }
                
                links.push({
                    source: sourceId,
                    target: targetId,
                    similarity: similarity,
                    reuse_type: match.reuse_type,
                    shared_content: match.shared_content,
                    source_date: match.source_date,
                    target_date: match.target_date,
                    sourcePublication: match.source_publication,
                    targetPublication: match.target_publication,
                    linkColor: linkColor,
                    linkOpacity: linkOpacity,
                    isDashed: isDashed,
                    isCrossPublication: sourceNode.publication !== targetNode.publication
                });
            }
        });
        
        // Update node link counts and sizes
        nodes.forEach(node => {
            const count = linkCounts[node.id] || 0;
            node.linkCount = count;
            node.size = Math.max(5, Math.min(20, 8 + count * 1.5));
        });
        
        // Set up SVG (rest of function remains the same as original)
        const container = d3.select("#d3-network");
        const width = container.node().getBoundingClientRect().width;
        const height = 700;
        
        const svg = container
            .append("svg")
            .attr("width", width)
            .attr("height", height);
        
        // Add zoom behavior
        const g = svg.append("g");
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });
        
        svg.call(zoom);

        function getPageInfo(pageId) {
            // Handle case where pageId might be an object (due to D3 link processing)
            const actualPageId = typeof pageId === 'object' ? pageId.id : pageId;
    
            // Find the page in globalMetadata
            const pageData = globalMetadata.find(page => page.page_id === actualPageId);
    
            if (pageData) {
                const volume = pageData.volume ? `Vol. ${pageData.volume}` : '';
                const number = pageData.number ? `No. ${pageData.number}` : '';
                const pageNum = pageData.page_number ? `Page ${pageData.page_number}` : '';
                const date = pageData.issue_date ? `Issue Date ${pageData.issue_date}` : '';
                console.log('Date found:', date); // Debug line

                const parts = [pageData.publication_name, volume, number, pageNum].filter(Boolean);
                const info = parts.join(', ');

                return date ? `${info}<br><strong>Date:</strong> ${date}` : info;
            }
    
            return `Page ${actualPageId}`;
        }
        
        // Create tooltip
        const tooltip = d3.select("body").select(".tooltip").empty() ? 
            d3.select("body").append("div").attr("class", "tooltip") :
            d3.select("body").select(".tooltip");
        
        // Create force simulation
        simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(d => d.isCrossPublication ? 150 : 100)
                .strength(d => Math.max(0.1, d.similarity * 1.5))
            )
            .force("charge", d3.forceManyBody()
                .strength(d => -200 - (d.linkCount * 10))
            )
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide()
                .radius(d => d.size + 3)
            )
            .force("x", d3.forceX(width / 2).strength(0.1))
            .force("y", d3.forceY(height / 2).strength(0.1));
        
        // Create links
        const link = g.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(links)
            .enter().append("line")
            .attr("stroke", d => d.linkColor)
            .attr("stroke-opacity", d => d.linkOpacity)
            .attr("stroke-width", d => Math.max(1, d.similarity * 8))
            .attr("stroke-dasharray", "none")
            .on("mouseover", (event, d) => {
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`
                    <strong>${getPageInfo(d.source)} â†’ ${getPageInfo(d.target)}</strong><br/>
                    Reuse Type: ${d.reuse_type.replace('_', ' ')}<br/>
                    Similarity: ${(d.similarity * 100).toFixed(1)}%<br/>
                    Source Date: ${d.source_date}<br/>
                    Target Date: ${d.target_date}<br/>
                    Shared Content:<br/>
                    "${d.shared_content ? d.shared_content.substring(0, 200) + '...' : 'N/A'}"
                `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", () => {
                tooltip.transition().duration(500).style("opacity", 0);
            });
        
        // Create nodes
        const node = g.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("r", d => d.size)
            .attr("fill", d => d.color)
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))
            .on("mouseover", (event, d) => {
                // Highlight connected nodes
                const connectedNodeIds = new Set();
                links.forEach(link => {
                    if (link.source.id === d.id) connectedNodeIds.add(link.target.id);
                    if (link.target.id === d.id) connectedNodeIds.add(link.source.id);
                });
                
                node.style("opacity", n => connectedNodeIds.has(n.id) || n.id === d.id ? 1 : 0.3);
                link.style("opacity", l => l.source.id === d.id || l.target.id === d.id ? 1 : 0.1);
                
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html(`
                    <strong>Page ID:</strong> ${d.id}<br>
                    ${getPageInfo(d.id)}<br>
                    <strong>Connections:</strong> ${d.linkCount}
                `)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", () => {
                node.style("opacity", 1);
                link.style("opacity", d => d.linkOpacity);
                tooltip.transition().duration(500).style("opacity", 0);
            });
        
        // Update positions on simulation tick
        simulation.on("tick", () => {
            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
        });
        
        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Store svg reference for controls
        networkSvg = svg;
        
        // Reset zoom function
        window.resetZoom = function() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        };
        
        console.log(`D3 Network: ${nodes.length} nodes, ${links.length} links (${links.filter(l => l.isCrossPublication).length} cross-publication)`);
    }

    // Update publication filter
    function populatePublicationFilter(metadata) {
        const publications = [...new Set(metadata.map(d => d.publication_name))].filter(Boolean).sort();
        
        const publicationFilter = document.getElementById('publication-filter');
        publicationFilter.innerHTML = '<option value="all">All Publications</option>';
        
        publications.forEach(pub => {
            const option = document.createElement('option');
            option.value = pub;
            option.textContent = pub;
            publicationFilter.appendChild(option);
        });
    }

    // Apply current filter settings (remove similarity threshold)
    function applyCurrentFilters(data) {
        const reuseTypeFilter = document.getElementById("reuse-type-filter").value;
        const publicationFilter = document.getElementById("publication-filter").value;

        return data.filter(d => {
            let passes = true;
            
            if (reuseTypeFilter !== "all") {
                passes = passes && d.reuse_type === reuseTypeFilter;
            }
            
            if (publicationFilter !== "all") {
                passes = passes && (d.source_publication === publicationFilter || 
                                  d.target_publication === publicationFilter);
            }
            
            return passes;
        });
    }

    // Update network with current filters
    function updateNetwork() {
        if (!globalReuseData) return;
        createD3PageNetwork(globalReuseData);
        populatePublicationLegend();
    }

    // Setup control event listeners (remove similarity slider)
    function setupControls() {
        // Populate publication filter
        populatePublicationFilter(globalMetadata);
        
        // Filter dropdowns
        document.getElementById("reuse-type-filter").addEventListener("change", updateNetwork);
        document.getElementById("publication-filter").addEventListener("change", updateNetwork);

        // Reset zoom button
        document.getElementById("reset-zoom").addEventListener("click", function() {
            if (window.resetZoom) window.resetZoom();
        });
    }
</script>
{% endblock %}