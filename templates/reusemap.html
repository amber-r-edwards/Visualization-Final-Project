{% extends "base.html" %}

{% block title %}Geographic Network - Feminist Zine Text Reuse Analysis{% endblock %}

{% block content %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="{{ url_for('static', filename='js/publication-colors.js') }}" onerror="console.error('Failed to load publication-colors.js')"></script>

<style>
    .container {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    h1 {
        color: #333;
        border-bottom: 3px solid #007bff;
        padding-bottom: 10px;
    }
    .d3-network-container {
        width: 100%;
        height: 700px;
        margin: 20px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
        position: relative;
    }
    .d3-controls {
        margin-bottom: 10px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .d3-controls label {
        margin-right: 15px;
        font-weight: bold;
    }
    .d3-controls input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    .d3-controls select {
        margin: 0 10px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 3px;
    }
    .d3-controls span {
        font-weight: normal;
        color: #666;
    }
    .d3-controls button {
        margin-left: 15px;
        padding: 8px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    .d3-controls button:hover {
        background-color: #0056b3;
    }
    .stats {
        display: flex;
        justify-content: space-around;
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin: 20px 0;
    }
    .stat-item {
        text-align: center;
    }
    .stat-number {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
    }
    .stat-label {
        font-size: 12px;
        color: #666;
    }
    .legend {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .legend-section {
        margin-bottom: 15px;
    }
    .legend-item {
        display: inline-flex;
        align-items: center;
        margin-right: 15px;
        margin-bottom: 8px;
    }
    .legend-color {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border-radius: 3px;
    }
    .publication-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 5px;
    }
</style>

<div class="container">
    <h1>Geographic Text Reuse Network</h1>
    <p>Interactive geographic visualization showing cross-publication text reuse patterns among feminist publications from 1970-1975</p>
    
    <div id="loading" style="text-align: center; padding: 2rem; color: #666;">
        Loading geographic data...
    </div>
    
    <div id="stats" class="stats" style="display: none;">
        <div class="stat-item">
            <div id="total-connections" class="stat-number">0</div>
            <div class="stat-label">Cross-Publication Connections</div>
        </div>
        <div class="stat-item">
            <div id="total-cities" class="stat-number">0</div>
            <div class="stat-label">Cities</div>
        </div>
        <div class="stat-item">
            <div id="publications-count" class="stat-number">0</div>
            <div class="stat-label">Publications</div>
        </div>
        <div class="stat-item">
            <div id="avg-similarity" class="stat-number">0.0</div>
            <div class="stat-label">Avg. Similarity</div>
        </div>
    </div>

    <div class="d3-controls">
        <label>Filter by Reuse Type:
            <select id="reuse-type-filter">
                <option value="all">All Types</option>
                <option value="minimal_reuse">Minimal Reuse</option>
                <option value="partial_reuse">Partial Reuse</option>
                <option value="moderate_reuse">Moderate Reuse</option>
            </select>
        </label>
        <label>Filter by Publication:
            <select id="publication-filter">
                <option value="all">All Publications</option>
            </select>
        </label>
        <button id="refresh-geo-map">Update Map</button>
        <button id="reset-map-zoom">Reset Zoom</button>
    </div>
    
    <div id="geographic-network" class="d3-network-container"></div>
    
    <div class="legend">
        <div class="legend-section">
            <h3>Reuse Types (Edge Colors)</h3>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #95a5a6;"></div>
                <span>Minimal Reuse</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f39c12;"></div>
                <span>Partial Reuse</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>Moderate Reuse</span>
            </div>
        </div>
        
        <div class="legend-section">
            <h3>Publications (Node Colors)</h3>
            <div id="publication-legend" class="publication-legend">
                <!-- Publication colors will be populated by JavaScript -->
            </div>
        </div>
        
        <p><strong>Cities:</strong> Node size = number of pages | <strong>Connections:</strong> Only cross-publication reuse | <strong>Line thickness:</strong> Similarity strength</p>
    </div>
</div>

<script>
    // Global variables
    let globalReuseData = null;
    let globalMetadata = null;
    let geoSvg = null;
    let geoZoom = null;
    let pubLookupById = {}; // Add this line

    // City coordinates (expanded for 1970-1975 data)
    const cityCoordinates = {
        'Iowa City, IA': { lat: 41.6612, lon: -91.5302 },
        'Denver, CO': { lat: 39.7392, lon: -104.9903 },
        'Minneapolis, MN': { lat: 44.9778, lon: -93.2650 },
        'St. Paul, MN': { lat: 44.9537, lon: -93.0900 },
        'Minneapolis-St.Paul, MN': { lat: 44.9653, lon: -93.1778 },
        'Chicago, IL': { lat: 41.8781, lon: -87.6298 },
        'New York, NY': { lat: 40.7128, lon: -74.0060 },
        'Washington, DC': { lat: 38.9072, lon: -77.0369 },
        'San Francisco, CA': { lat: 37.7749, lon: -122.4194 },
        'Los Angeles, CA': { lat: 34.0522, lon: -118.2437 },
        'Boston, MA': { lat: 42.3601, lon: -71.0589 },
        'Philadelphia, PA': { lat: 39.9526, lon: -75.1652 },
        'Berkeley, CA': { lat: 37.8715, lon: -122.2730 },
        'Oakland, CA': { lat: 37.8044, lon: -122.2712 },
        'Seattle, WA': { lat: 47.6062, lon: -122.3321 },
        'Portland, OR': { lat: 45.5152, lon: -122.6784 },
        'Austin, TX': { lat: 30.2672, lon: -97.7431 },
        'Atlanta, GA': { lat: 33.7490, lon: -84.3880 },
        'Detroit, MI': { lat: 42.3314, lon: -83.0458 },
        'Madison, WI': { lat: 43.0731, lon: -89.4012 },
        'Chapel Hill, NC': { lat: 35.9132, lon: -79.0558 },
        'Cambridge, MA': { lat: 42.3736, lon: -71.1097 },
        'Baltimore, MD': { lat: 39.2904, lon: -76.6122 }
    };

    // Helper functions
    function getReuseTypeColor(reuseType) {
    return reuseTypeColorManager.getColor(reuseType);
}

    function applyCurrentFilters(data) {
        const reuseTypeFilter = document.getElementById("reuse-type-filter").value;
        const publicationFilter = document.getElementById("publication-filter").value;

        return data.filter(d => {
            let passes = true;
            
            if (reuseTypeFilter !== "all") {
                passes = passes && d.reuse_type === reuseTypeFilter;
            }
            
            
            if (publicationFilter !== "all") {
                passes = passes && (d.source_publication === publicationFilter || 
                                  d.target_publication === publicationFilter);
            }
            
            return passes;
        });
    }

    function updateStats(connections, cities, publications, avgSimilarity) {
        document.getElementById('total-connections').textContent = connections;
        document.getElementById('total-cities').textContent = cities;
        document.getElementById('publications-count').textContent = publications;
        document.getElementById('avg-similarity').textContent = avgSimilarity.toFixed(3);
    }

    // Main geographic network function
    function createGeographicNetwork(reuse_data, metadata) {
        console.log('Creating geographic network with', reuse_data.length, 'reuse data points');
        console.log('Metadata entries:', metadata.length);
        
        // Clear previous map
        d3.select("#geographic-network").selectAll("*").remove();
        
        // Create metadata lookup by page_id for faster access
        const metadataLookup = new Map();
        metadata.forEach(page => {
            metadataLookup.set(page.page_id, page);
        });
        
        console.log('Metadata lookup created with', metadataLookup.size, 'entries');
        
        // Apply filters
        let filteredReuse = applyCurrentFilters(reuse_data);
        console.log(`After filtering: ${filteredReuse.length} matches`);

        if (filteredReuse.length === 0) {
            d3.select("#geographic-network")
                .append("div")
                .style("text-align", "center")
                .style("padding", "50px")
                .style("color", "#666")
                .text("No cross-publication connections match current filters");
            return;
        }

        // Group data by location and create city data
        const cityData = new Map();
        const individualConnections = [];

        // Process each match to create geographic connections
        filteredReuse.forEach(match => {
            // Get metadata for source and target pages
            const sourcePage = metadataLookup.get(match.source_page_id);
            const targetPage = metadataLookup.get(match.target_page_id);

            if (!sourcePage || !targetPage) {
                console.log('Missing metadata for pages:', match.source_page_id, match.target_page_id);
                return;
            }

            // Get locations from metadata
            const sourceLocation = sourcePage.location;
            const targetLocation = targetPage.location;

            if (!sourceLocation || !targetLocation) {
                console.log('Missing location in metadata:', sourceLocation, targetLocation);
                return;
            }

            // Only process cross-publication connections
            const sourcePublication = sourcePage.publication_name;
            const targetPublication = targetPage.publication_name;
            const isCrossPublication = sourcePublication !== targetPublication;
            
            if (!isCrossPublication) {
                return; // Skip within-publication connections
            }

            // Store city data
            [sourceLocation, targetLocation].forEach(location => {
                if (!cityData.has(location)) {
                    cityData.set(location, {
                        location: location,
                        coords: cityCoordinates[location],
                        publications: new Set(),
                        pageCount: 0,
                        connections: 0
                    });
                }
            });

            // Add publications and increment counters
            cityData.get(sourceLocation).publications.add(sourcePublication);
            cityData.get(targetLocation).publications.add(targetPublication);
            cityData.get(sourceLocation).connections++;
            cityData.get(targetLocation).connections++;

            // Create connection object
            individualConnections.push({
                sourceCity: sourceLocation,
                targetCity: targetLocation,
                sourcePageId: match.source_page_id,
                targetPageId: match.target_page_id,
                similarity: match.combined_similarity,
                reuse_type: match.reuse_type,
                sourcePublication: sourcePublication,
                targetPublication: targetPublication,
                sourceDate: match.source_date,
                targetDate: match.target_date,
                sourcePage: sourcePage,
                targetPage: targetPage,
                isCrossPublication: true,
                color: getReuseTypeColor(match.reuse_type)
            });
        });

        // Count all pages by location from metadata
        const locationCounts = {};
        metadata.forEach(page => {
            if (page.location) {
                locationCounts[page.location] = (locationCounts[page.location] || 0) + 1;
                
                // Ensure city exists in cityData
                if (!cityData.has(page.location)) {
                    cityData.set(page.location, {
                        location: page.location,
                        coords: cityCoordinates[page.location],
                        publications: new Set([page.publication_name]),
                        pageCount: 0,
                        connections: 0
                    });
                }
                
                cityData.get(page.location).publications.add(page.publication_name);
            }
        });

        // Update page counts
        cityData.forEach((data, location) => {
            data.pageCount = locationCounts[location] || 0;
        });

        // Filter out cities without valid coordinates
        const validCities = Array.from(cityData.values()).filter(city => {
            return city.coords && city.coords.lat && city.coords.lon;
        });

        const validConnections = individualConnections.filter(conn => {
            const sourceCoords = cityCoordinates[conn.sourceCity];
            const targetCoords = cityCoordinates[conn.targetCity];
            return sourceCoords && targetCoords;
        });

        console.log('Valid cities:', validCities.length);
        console.log('Valid cross-publication connections:', validConnections.length);

        if (validCities.length === 0) {
            d3.select("#geographic-network").append("div")
                .style("padding", "20px")
                .style("text-align", "center")
                .style("color", "red")
                .text("No geographic data found. Check that location data matches city coordinates.");
            return;
        }

        // Update stats
        const totalPublications = new Set(Array.from(cityData.values()).flatMap(city => Array.from(city.publications))).size;
        const avgSimilarity = validConnections.reduce((sum, conn) => sum + conn.similarity, 0) / validConnections.length || 0;
        updateStats(validConnections.length, validCities.length, totalPublications, avgSimilarity);

        // Set up map dimensions
        const width = 1000;
        const height = 600;

        // Create SVG
        const svg = d3.select("#geographic-network")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Set up projection
        const projection = d3.geoAlbersUsa()
            .scale(1200)
            .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        // Add zoom behavior
        geoZoom = d3.zoom()
            .scaleExtent([0.5, 8])
            .on("zoom", (event) => {
                svg.select(".map-group").attr("transform", event.transform);
            });

        svg.call(geoZoom);

        const g = svg.append("g").attr("class", "map-group");

        // Helper function to create curved path between two points
        function createCurvedPath(source, target, curvature = 0.3) {
            const sourceCoords = projection([source.lon, source.lat]);
            const targetCoords = projection([target.lon, target.lat]);
            
            if (!sourceCoords || !targetCoords) return "";
            
            const dx = targetCoords[0] - sourceCoords[0];
            const dy = targetCoords[1] - sourceCoords[1];
            const dr = Math.sqrt(dx * dx + dy * dy) * curvature;
            
            return `M${sourceCoords[0]},${sourceCoords[1]}A${dr},${dr} 0 0,1 ${targetCoords[0]},${targetCoords[1]}`;
        }

        // Group connections by city pair to create varying curvatures
        const connectionGroups = new Map();
        validConnections.forEach(conn => {
            const key = conn.sourceCity < conn.targetCity ? 
                `${conn.sourceCity}-${conn.targetCity}` : 
                `${conn.targetCity}-${conn.sourceCity}`;
            
            if (!connectionGroups.has(key)) {
                connectionGroups.set(key, []);
            }
            connectionGroups.get(key).push(conn);
        });

        // Assign varying curvatures
        connectionGroups.forEach(connections => {
            if (connections.length === 1) {
                connections[0].curvature = 0.2;
            } else {
                connections.forEach((conn, i) => {
                    conn.curvature = 0.1 + (i / (connections.length - 1)) * 0.5;
                });
            }
        });

        // Load and draw US map
        d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(us => {
            console.log("Map data loaded successfully");
            
            // Draw states
            g.append("g")
                .selectAll("path")
                .data(topojson.feature(us, us.objects.states).features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", "#f0f0f0")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 1);

            // Create tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "geo-tooltip")
                .style("position", "absolute")
                .style("padding", "10px")
                .style("background", "rgba(0, 0, 0, 0.9)")
                .style("color", "white")
                .style("border-radius", "6px")
                .style("font-size", "12px")
                .style("pointer-events", "none")
                .style("opacity", 0)
                .style("max-width", "300px")
                .style("z-index", "1000");

            // Draw connections
            if (validConnections.length > 0) {
                g.append("g")
                    .attr("class", "connections")
                    .selectAll("path")
                    .data(validConnections)
                    .enter()
                    .append("path")
                    .attr("d", d => createCurvedPath(
                        cityCoordinates[d.sourceCity], 
                        cityCoordinates[d.targetCity], 
                        d.curvature
                    ))
                    .attr("stroke", d => d.color)
                    .attr("stroke-width", d => Math.max(2, Math.min(6, d.similarity * 10)))
                    .attr("stroke-opacity", 0.7)
                    .attr("fill", "none")
                    .style("cursor", "pointer")
                    .on("mouseover", (event, d) => {
                        d3.select(event.target)
                            .attr("stroke-width", Math.max(4, Math.min(8, d.similarity * 12)))
                            .attr("stroke-opacity", 1);
                        
                        tooltip.transition().duration(200).style("opacity", .95);
                        tooltip.html(`
                            <div style="font-weight: bold; margin-bottom: 5px;">
                                ${d.sourceCity} â†” ${d.targetCity}
                             </div>
                            <div><strong>Source:</strong> ${d.sourcePublication} (Page ${d.sourcePageId})</div>
                            <div><strong>Target:</strong> ${d.targetPublication} (Page ${d.targetPageId})</div>
                            <div><strong>Reuse Type:</strong> ${d.reuse_type.replace('_', ' ')}</div>
                            <div><strong>Similarity:</strong> ${(d.similarity * 100).toFixed(1)}%</div>
                            <div><strong>Source Date:</strong> ${d.sourceDate}</div>
                            <div><strong>Target Date:</strong> ${d.targetDate}</div>
                            <div style="color: #ffd700;">Cross-publication reuse</div>
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", (event, d) => {
                        d3.select(event.target)
                            .attr("stroke-width", Math.max(2, Math.min(6, d.similarity * 10)))
                            .attr("stroke-opacity", 0.7);
                        
                        tooltip.transition().duration(300).style("opacity", 0);
                    });
            }

            // Draw cities
            g.append("g")
                .attr("class", "cities")
                .selectAll("circle")
                .data(validCities)
                .enter()
                .append("circle")
                .attr("cx", d => projection([d.coords.lon, d.coords.lat])[0])
                .attr("cy", d => projection([d.coords.lon, d.coords.lat])[1])
                .attr("r", d => Math.max(8, Math.min(25, d.pageCount * 2)))
                .attr("fill", d => {
                    const pubs = Array.from(d.publications);
                    // Get the pub_id for the primary publication
                    const primaryPub = pubs[0];
    
                    // Find the pub_id for this publication name from our metadata
                    let pubId = null;
                    for (const [pageId, pageInfo] of Object.entries(pubLookupById)) {
                        if (pageInfo.publication_name === primaryPub) {
                            pubId = pageInfo.pub_id;
                            break;
                        }
                    }
    
                    // Use pub_id to get color, fallback to name if needed
                    return pubId ? publicationColorManager.getColorById(pubId) : publicationColorManager.getColor(primaryPub);
                })
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.9)
                .style("cursor", "pointer")
                .on("mouseover", (event, d) => {
                    const publicationsList = Array.from(d.publications).join(", ");
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(`
                        <div style="font-weight: bold; margin-bottom: 5px;">${d.location}</div>
                        <div><strong>Pages:</strong> ${d.pageCount}</div>
                        <div><strong>Cross-pub Connections:</strong> ${d.connections}</div>
                        <div><strong>Publications:</strong> ${publicationsList}</div>
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(300).style("opacity", 0);
                });

            // Add city labels
            g.append("g")
                .attr("class", "city-labels")
                .selectAll("text")
                .data(validCities)
                .enter()
                .append("text")
                .attr("x", d => projection([d.coords.lon, d.coords.lat])[0])
                .attr("y", d => projection([d.coords.lon, d.coords.lat])[1] - Math.max(10, Math.min(27, d.pageCount * 2)))
                .attr("text-anchor", "middle")
                .style("font-size", "11px")
                .style("font-weight", "bold")
                .style("fill", "#333")
                .style("text-shadow", "1px 1px 2px white, -1px -1px 2px white, 1px -1px 2px white, -1px 1px 2px white")
                .text(d => d.location.split(',')[0])
                .style("pointer-events", "none");

            // Store svg reference for controls
            geoSvg = svg;

            console.log(`Geographic Network complete: ${validCities.length} cities, ${validConnections.length} cross-publication connections`);

        }).catch(error => {
            console.error("Error loading map data:", error);
            d3.select("#geographic-network").append("div")
                .style("padding", "20px")
                .style("text-align", "center")
                .style("color", "red")
                .text("Error loading map data. Check console for details.");
        });
    }

    function setupControls() {
        console.log('Setting up geographic controls...');

        // Filter dropdowns
        const reuseTypeFilter = document.getElementById("reuse-type-filter");
        const publicationFilter = document.getElementById("publication-filter");
        
        if (reuseTypeFilter) {
            reuseTypeFilter.addEventListener("change", updateGeoNetwork);
        }
        
        if (publicationFilter) {
            publicationFilter.addEventListener("change", updateGeoNetwork);
        }

        // Update button
        const updateButton = document.getElementById("refresh-geo-map");
        if (updateButton) {
            updateButton.addEventListener("click", updateGeoNetwork);
        }

        // Reset zoom button
        const resetButton = document.getElementById("reset-map-zoom");
        if (resetButton) {
            resetButton.addEventListener("click", function() {
                if (geoSvg && geoZoom) {
                    geoSvg.transition().duration(750).call(
                        geoZoom.transform,
                        d3.zoomIdentity
                    );
                }
            });
        }
        
        console.log('Geographic controls set up successfully');
    }

    function updateGeoNetwork() {
        if (!globalReuseData || !globalMetadata) return;
        createGeographicNetwork(globalReuseData, globalMetadata);
    }

    function populatePublicationFilter(metadata) {
        const publications = [...new Set(metadata.map(d => d.publication_name))].filter(Boolean).sort();
        
        const publicationFilter = document.getElementById('publication-filter');
        publicationFilter.innerHTML = '<option value="all">All Publications</option>';
        
        publications.forEach(pub => {
            const option = document.createElement('option');
            option.value = pub;
            option.textContent = pub;
            publicationFilter.appendChild(option);
        });
    }

    // Replace the entire "Main data loading" section at the bottom with this:
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, starting direct CSV data load...');
        
        // Load CSV files directly
        Promise.all([
            d3.csv("{{ url_for('static', filename='data/text_reuse_ngrams_windowed_parallel_filtered.csv') }}"),
            d3.csv("{{ url_for('static', filename='data/zinepage_metadata.csv') }}"),
            d3.csv("{{ url_for('static', filename='data/zinepub_metadata.csv') }}")
        ]).then(function([reuseData, pageMetadata, pubMetadata]) {
            console.log('Raw CSV data loaded:');
            console.log('- Reuse data:', reuseData.length, 'records');
            console.log('- Page metadata:', pageMetadata.length, 'records');
            console.log('- Publication metadata:', pubMetadata.length, 'records');
            
            if (!reuseData || reuseData.length === 0) {
                throw new Error('No reuse data found in CSV');
            }
            
           // Process the data
// 1. Create publication lookup using pub_id instead of publication_name
pubLookupById = {}; // Use the global variable instead of const
pageMetadata.forEach(page => {
    pubLookupById[page.page_id] = {
        publication_name: page.publication_name,
        pub_id: page.pub_id
    };
});

// 2. Create publication metadata lookup by pub_id
const pubMetadataLookup = {};
pubMetadata.forEach(pub => {
    pubMetadataLookup[pub.pub_id] = pub;
});

console.log('Publication metadata lookup created with pub_ids:', Object.keys(pubMetadataLookup));
console.log('Sample page with pub_id:', pageMetadata.slice(0, 3).map(p => ({
    page_id: p.page_id,
    pub_id: p.pub_id,
    publication_name: p.publication_name
})));

// 3. Process reuse data and add publication names using pub_id
const processedReuseData = reuseData.map(d => {
    // Get publication info from page metadata using pub_id
    const sourcePageInfo = pubLookupById[d.source_page_id];
    const targetPageInfo = pubLookupById[d.target_page_id];
    
    const sourcePub = sourcePageInfo ? sourcePageInfo.publication_name : 'Unknown';
    const targetPub = targetPageInfo ? targetPageInfo.publication_name : 'Unknown';
    
    // Determine reuse type based on similarity score
    const similarity = +d.combined_similarity;
    let reuseType;
    if (similarity < 0.3) {
        reuseType = 'minimal_reuse';
    } else if (similarity < 0.7) {
        reuseType = 'partial_reuse';
    } else {
        reuseType = 'moderate_reuse';
    }
    
    return {
        source_page_id: d.source_page_id,
        target_page_id: d.target_page_id,
        combined_similarity: +d.combined_similarity,
        ngram_similarity: +(d.ngram_similarity || 0),
        shingle_similarity: +(d.shingle_similarity || 0),
        source_publication: sourcePub,
        target_publication: targetPub,
        source_date: d.source_date || '',
        target_date: d.target_date || '',
        reuse_type: reuseType,
        shared_content: d.shared_content || ''
    };
});

// 4. Combine page and publication metadata using pub_id
const combinedMetadata = pageMetadata.map(page => {
    // Get publication metadata using pub_id
    const pubData = pubMetadataLookup[page.pub_id] || {};
    
    return {
        page_id: page.page_id,
        pub_id: page.pub_id,
        publication_name: page.publication_name,
        volume: page.volume || '',
        number: page.number || '',
        page_number: page.page_number || '',
        organization: pubData.organization || '',
        location: pubData.location || '', // Location from publication metadata via pub_id
        region: pubData.region || '',
        notes: pubData.notes || ''
    };
});

// Updated debugging to verify the pub_id matching:
console.log('=== PUB_ID MATCHING DEBUGGING ===');
console.log('Total pages:', pageMetadata.length);
console.log('Total pub metadata entries:', pubMetadata.length);
console.log('Pages with pub_id:', pageMetadata.filter(p => p.pub_id).length);
console.log('Pub metadata entries with pub_id:', pubMetadata.filter(p => p.pub_id).length);

console.log('Sample combined metadata with locations:', 
    combinedMetadata.filter(p => p.location).slice(0, 5).map(p => ({ 
        page_id: p.page_id,
        pub_id: p.pub_id,
        location: p.location, 
        publication_name: p.publication_name 
    }))
);
console.log('Total pages with locations after pub_id matching:', 
    combinedMetadata.filter(p => p.location).length);

// Check pub_id matching success
const successfulMatches = combinedMetadata.filter(p => p.location).length;
const totalPages = combinedMetadata.length;
console.log(`Location matching success rate: ${successfulMatches}/${totalPages} (${((successfulMatches/totalPages)*100).toFixed(1)}%)`);

console.log('Available city coordinates:', Object.keys(cityCoordinates));
console.log('=== END DEBUGGING ===');
            
            // Store globally for use by other functions
            globalReuseData = processedReuseData;
            globalMetadata = combinedMetadata;
            
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';
            document.getElementById('stats').style.display = 'flex';
            
            // Populate filters
            populatePublicationFilter(combinedMetadata);
            
            // Initialize the network
            createGeographicNetwork(processedReuseData, combinedMetadata);
            setupControls();
            
            // Update the legend
            publicationColorManager.populateLegend('publication-legend');

        }).catch(function(error) {
            console.error("Error loading CSV data:", error);
            document.getElementById('loading').innerHTML = 
                `<div style="color: red; padding: 20px; background: #ffebee; border: 1px solid #f44336; border-radius: 5px;">
                    <h3>Error Loading Data</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>Make sure these CSV files exist in your static/data/ folder:</p>
                    <ul>
                        <li>text_reuse_ngrams_windowed_parallel_filtered.csv</li>
                        <li>zinepage_metadata.csv</li>
                        <li>zinepub_metadata.csv</li>
                    </ul>
                </div>`;
        });
    });
</script>
{% endblock %}