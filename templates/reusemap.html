{% extends "base.html" %}

{% block title %}Geographic Network - Feminist Zine Text Reuse Analysis{% endblock %}

{% block content %}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>
<script src="{{ url_for('static', filename='js/publication-colors.js') }}" onerror="console.error('Failed to load publication-colors.js')"></script>

<style>
    .container {
        background-color: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
    }
    h1 {
        color: #333;
        border-bottom: 3px solid #007bff;
        padding-bottom: 10px;
    }
    .d3-network-container {
        width: 100%;
        height: 700px;
        margin: 20px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
        position: relative;
    }
    .d3-controls {
        margin-bottom: 10px;
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .d3-controls label {
        margin-right: 15px;
        font-weight: bold;
    }
    .d3-controls input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    .d3-controls select {
        margin: 0 10px;
        padding: 5px;
        border: 1px solid #ccc;
        border-radius: 3px;
    }
    .d3-controls span {
        font-weight: normal;
        color: #666;
    }
    .d3-controls button {
        margin-left: 15px;
        padding: 8px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    .d3-controls button:hover {
        background-color: #0056b3;
    }
    .stats {
        display: flex;
        justify-content: space-around;
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin: 20px 0;
    }
    .stat-item {
        text-align: center;
    }
    .stat-number {
        font-size: 24px;
        font-weight: bold;
        color: #007bff;
    }
    .stat-label {
        font-size: 12px;
        color: #666;
    }
    .legend {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 5px;
    }
    .legend-section {
        margin-bottom: 15px;
    }
    .legend-item {
        display: inline-flex;
        align-items: center;
        margin-right: 15px;
        margin-bottom: 8px;
    }
    .legend-color {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border-radius: 3px;
    }
    .publication-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 5px;
    }
</style>

<div class="container">
    <h1>Geographic Text Reuse Network</h1>
    <p>Interactive geographic visualization showing cross-publication text reuse patterns among feminist publications from 1970-1975</p>
    
    <div id="loading" style="text-align: center; padding: 2rem; color: #666;">
        Loading geographic data...
    </div>
    
    <div id="stats" class="stats" style="display: none;">
        <div class="stat-item">
            <div id="total-connections" class="stat-number">0</div>
            <div class="stat-label">Cross-Publication Connections</div>
        </div>
        <div class="stat-item">
            <div id="total-cities" class="stat-number">0</div>
            <div class="stat-label">Cities</div>
        </div>
        <div class="stat-item">
            <div id="publications-count" class="stat-number">0</div>
            <div class="stat-label">Publications</div>
        </div>
        <div class="stat-item">
            <div id="avg-similarity" class="stat-number">0.0</div>
            <div class="stat-label">Avg. Similarity</div>
        </div>
    </div>

    <div class="d3-controls">
        <label>Geographic Similarity Threshold: 
            <input type="range" id="geo-similarity-slider" min="0" max="1" step="0.01" value="0.1">
            <span id="geo-similarity-value">0.10</span>
        </label>
        <label>Filter by Reuse Type:
            <select id="reuse-type-filter">
                <option value="all">All Types</option>
                <option value="minimal_reuse">Minimal Reuse</option>
                <option value="partial_reuse">Partial Reuse</option>
                <option value="moderate_reuse">Moderate Reuse</option>
            </select>
        </label>
        <label>Filter by Publication:
            <select id="publication-filter">
                <option value="all">All Publications</option>
            </select>
        </label>
        <button id="refresh-geo-map">Update Map</button>
        <button id="reset-map-zoom">Reset Zoom</button>
    </div>
    
    <div id="geographic-network" class="d3-network-container"></div>
    
    <div class="legend">
        <div class="legend-section">
            <h3>Reuse Types (Edge Colors)</h3>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #ff6b6b;"></div>
                <span>Minimal Reuse</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4ecdc4;"></div>
                <span>Partial Reuse</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #45b7d1;"></div>
                <span>Moderate Reuse</span>
            </div>
        </div>
        
        <div class="legend-section">
            <h3>Publications (Node Colors)</h3>
            <div id="publication-legend" class="publication-legend">
                <!-- Publication colors will be populated by JavaScript -->
            </div>
        </div>
        
        <p><strong>Cities:</strong> Node size = number of pages | <strong>Connections:</strong> Only cross-publication reuse | <strong>Line thickness:</strong> Similarity strength</p>
    </div>
</div>

<script>
    // Check if publicationColorManager exists, create fallback if not
    if (typeof publicationColorManager === 'undefined') {
        console.warn('publicationColorManager not found, creating fallback');
        
        window.publicationColorManager = {
            colors: {},
            colorPalette: [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
                '#A3E4D7', '#F9E79F', '#AED6F1', '#A9DFBF', '#F5B7B1'
            ],
            
            getColor: function(pubId, pubName) {
                if (!this.colors[pubId]) {
                    const colorIndex = Object.keys(this.colors).length % this.colorPalette.length;
                    this.colors[pubId] = {
                        color: this.colorPalette[colorIndex],
                        name: pubName
                    };
                }
                return this.colors[pubId].color;
            },
            
            populateLegend: function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                
                container.innerHTML = '';
                
                Object.entries(this.colors).forEach(([pubId, data]) => {
                    const legendItem = document.createElement('div');
                    legendItem.style.cssText = `
                        display: flex;
                        align-items: center;
                        gap: 0.5rem;
                        padding: 0.25rem 0.5rem;
                        margin: 0.25rem;
                        border-radius: 3px;
                        background: white;
                        border: 1px solid #ddd;
                        font-size: 0.85em;
                    `;
                    
                    legendItem.innerHTML = `
                        <div style="width: 16px; height: 16px; background: ${data.color}; border-radius: 3px; border: 1px solid #ccc;"></div>
                        <span>${data.name || `Publication ${pubId}`}</span>
                    `;
                    
                    container.appendChild(legendItem);
                });
            }
        };
    }

    // Global variables
    let globalReuseData = null;
    let globalMetadata = null;
    let geoSvg = null;
    let geoZoom = null;

    // City coordinates (expanded for 1970-1975 data)
    const cityCoordinates = {
        'Iowa City, IA': { lat: 41.6612, lon: -91.5302 },
        'Denver, CO': { lat: 39.7392, lon: -104.9903 },
        'Minneapolis, MN': { lat: 44.9778, lon: -93.2650 },
        'St. Paul, MN': { lat: 44.9537, lon: -93.0900 },
        'Minneapolis-St.Paul, MN': { lat: 44.9653, lon: -93.1778 },
        'Chicago, IL': { lat: 41.8781, lon: -87.6298 },
        'New York, NY': { lat: 40.7128, lon: -74.0060 },
        'Washington, DC': { lat: 38.9072, lon: -77.0369 },
        'San Francisco, CA': { lat: 37.7749, lon: -122.4194 },
        'Los Angeles, CA': { lat: 34.0522, lon: -118.2437 },
        'Boston, MA': { lat: 42.3601, lon: -71.0589 },
        'Philadelphia, PA': { lat: 39.9526, lon: -75.1652 },
        'Berkeley, CA': { lat: 37.8715, lon: -122.2730 },
        'Oakland, CA': { lat: 37.8044, lon: -122.2712 },
        'Seattle, WA': { lat: 47.6062, lon: -122.3321 },
        'Portland, OR': { lat: 45.5152, lon: -122.6784 },
        'Austin, TX': { lat: 30.2672, lon: -97.7431 },
        'Atlanta, GA': { lat: 33.7490, lon: -84.3880 },
        'Detroit, MI': { lat: 42.3314, lon: -83.0458 },
        'Madison, WI': { lat: 43.0731, lon: -89.4012 },
        'Chapel Hill, NC': { lat: 35.9132, lon: -79.0558 },
        'Cambridge, MA': { lat: 42.3736, lon: -71.1097 },
        'Baltimore, MD': { lat: 39.2904, lon: -76.6122 }
    };

    // Helper functions
    function getReuseTypeColor(reuseType) {
        const colors = {
            "minimal_reuse": '#ff6b6b',
            "partial_reuse": '#4ecdc4', 
            "moderate_reuse": '#45b7d1'
        };
        return colors[reuseType] || '#999';
    }

    function applyCurrentFilters(data) {
        const reuseTypeFilter = document.getElementById("reuse-type-filter").value;
        const similarityThreshold = +document.getElementById("geo-similarity-slider").value;
        const publicationFilter = document.getElementById("publication-filter").value;

        return data.filter(d => {
            let passes = true;
            
            if (reuseTypeFilter !== "all") {
                passes = passes && d.reuse_type === reuseTypeFilter;
            }
            
            passes = passes && d.combined_similarity >= similarityThreshold;
            
            if (publicationFilter !== "all") {
                passes = passes && (d.source_publication === publicationFilter || 
                                  d.target_publication === publicationFilter);
            }
            
            return passes;
        });
    }

    function updateStats(connections, cities, publications, avgSimilarity) {
        document.getElementById('total-connections').textContent = connections;
        document.getElementById('total-cities').textContent = cities;
        document.getElementById('publications-count').textContent = publications;
        document.getElementById('avg-similarity').textContent = avgSimilarity.toFixed(3);
    }

    function updateLegend() {
        console.log('Updating legend...');
        fetch('/api/publications')
            .then(response => response.json())
            .then(publications => {
                publications.forEach(pub => {
                    publicationColorManager.getColor(pub.pub_id, pub.publication_name);
                });
                publicationColorManager.populateLegend('publication-legend');
            })
            .catch(error => {
                console.error('Error loading publications for legend:', error);
            });
    }

    // Main geographic network function
    function createGeographicNetwork(reuse_data, metadata, similarityThreshold = 0.1) {
        console.log('Creating geographic network with', reuse_data.length, 'reuse data points');
        console.log('Metadata entries:', metadata.length);
        
        // Clear previous map
        d3.select("#geographic-network").selectAll("*").remove();
        
        // Create metadata lookup by page_id for faster access
        const metadataLookup = new Map();
        metadata.forEach(page => {
            metadataLookup.set(page.page_id, page);
        });
        
        console.log('Metadata lookup created with', metadataLookup.size, 'entries');
        
        // Apply filters
        let filteredReuse = applyCurrentFilters(reuse_data);
        console.log(`After filtering: ${filteredReuse.length} matches`);

        if (filteredReuse.length === 0) {
            d3.select("#geographic-network")
                .append("div")
                .style("text-align", "center")
                .style("padding", "50px")
                .style("color", "#666")
                .text("No cross-publication connections match current filters");
            return;
        }

        // Group data by location and create city data
        const cityData = new Map();
        const individualConnections = [];

        // Process each match to create geographic connections
        filteredReuse.forEach(match => {
            // Get metadata for source and target pages
            const sourcePage = metadataLookup.get(match.source_page_id);
            const targetPage = metadataLookup.get(match.target_page_id);

            if (!sourcePage || !targetPage) {
                console.log('Missing metadata for pages:', match.source_page_id, match.target_page_id);
                return;
            }

            // Get locations from metadata
            const sourceLocation = sourcePage.location;
            const targetLocation = targetPage.location;

            if (!sourceLocation || !targetLocation) {
                console.log('Missing location in metadata:', sourceLocation, targetLocation);
                return;
            }

            // Only process cross-publication connections
            const sourcePublication = sourcePage.publication_name;
            const targetPublication = targetPage.publication_name;
            const isCrossPublication = sourcePublication !== targetPublication;
            
            if (!isCrossPublication) {
                return; // Skip within-publication connections
            }

            // Store city data
            [sourceLocation, targetLocation].forEach(location => {
                if (!cityData.has(location)) {
                    cityData.set(location, {
                        location: location,
                        coords: cityCoordinates[location],
                        publications: new Set(),
                        pageCount: 0,
                        connections: 0
                    });
                }
            });

            // Add publications and increment counters
            cityData.get(sourceLocation).publications.add(sourcePublication);
            cityData.get(targetLocation).publications.add(targetPublication);
            cityData.get(sourceLocation).connections++;
            cityData.get(targetLocation).connections++;

            // Create connection object
            individualConnections.push({
                sourceCity: sourceLocation,
                targetCity: targetLocation,
                sourcePageId: match.source_page_id,
                targetPageId: match.target_page_id,
                similarity: match.combined_similarity,
                reuse_type: match.reuse_type,
                sourcePublication: sourcePublication,
                targetPublication: targetPublication,
                sourceDate: match.source_date,
                targetDate: match.target_date,
                sourcePage: sourcePage,
                targetPage: targetPage,
                isCrossPublication: true,
                color: getReuseTypeColor(match.reuse_type)
            });
        });

        // Count all pages by location from metadata
        const locationCounts = {};
        metadata.forEach(page => {
            if (page.location) {
                locationCounts[page.location] = (locationCounts[page.location] || 0) + 1;
                
                // Ensure city exists in cityData
                if (!cityData.has(page.location)) {
                    cityData.set(page.location, {
                        location: page.location,
                        coords: cityCoordinates[page.location],
                        publications: new Set([page.publication_name]),
                        pageCount: 0,
                        connections: 0
                    });
                }
                
                cityData.get(page.location).publications.add(page.publication_name);
            }
        });

        // Update page counts
        cityData.forEach((data, location) => {
            data.pageCount = locationCounts[location] || 0;
        });

        // Filter out cities without valid coordinates
        const validCities = Array.from(cityData.values()).filter(city => {
            return city.coords && city.coords.lat && city.coords.lon;
        });

        const validConnections = individualConnections.filter(conn => {
            const sourceCoords = cityCoordinates[conn.sourceCity];
            const targetCoords = cityCoordinates[conn.targetCity];
            return sourceCoords && targetCoords;
        });

        console.log('Valid cities:', validCities.length);
        console.log('Valid cross-publication connections:', validConnections.length);

        if (validCities.length === 0) {
            d3.select("#geographic-network").append("div")
                .style("padding", "20px")
                .style("text-align", "center")
                .style("color", "red")
                .text("No geographic data found. Check that location data matches city coordinates.");
            return;
        }

        // Update stats
        const totalPublications = new Set(Array.from(cityData.values()).flatMap(city => Array.from(city.publications))).size;
        const avgSimilarity = validConnections.reduce((sum, conn) => sum + conn.similarity, 0) / validConnections.length || 0;
        updateStats(validConnections.length, validCities.length, totalPublications, avgSimilarity);

        // Set up map dimensions
        const width = 1000;
        const height = 600;

        // Create SVG
        const svg = d3.select("#geographic-network")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

        // Set up projection
        const projection = d3.geoAlbersUsa()
            .scale(1200)
            .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        // Add zoom behavior
        geoZoom = d3.zoom()
            .scaleExtent([0.5, 8])
            .on("zoom", (event) => {
                svg.select(".map-group").attr("transform", event.transform);
            });

        svg.call(geoZoom);

        const g = svg.append("g").attr("class", "map-group");

        // Helper function to create curved path between two points
        function createCurvedPath(source, target, curvature = 0.3) {
            const sourceCoords = projection([source.lon, source.lat]);
            const targetCoords = projection([target.lon, target.lat]);
            
            if (!sourceCoords || !targetCoords) return "";
            
            const dx = targetCoords[0] - sourceCoords[0];
            const dy = targetCoords[1] - sourceCoords[1];
            const dr = Math.sqrt(dx * dx + dy * dy) * curvature;
            
            return `M${sourceCoords[0]},${sourceCoords[1]}A${dr},${dr} 0 0,1 ${targetCoords[0]},${targetCoords[1]}`;
        }

        // Group connections by city pair to create varying curvatures
        const connectionGroups = new Map();
        validConnections.forEach(conn => {
            const key = conn.sourceCity < conn.targetCity ? 
                `${conn.sourceCity}-${conn.targetCity}` : 
                `${conn.targetCity}-${conn.sourceCity}`;
            
            if (!connectionGroups.has(key)) {
                connectionGroups.set(key, []);
            }
            connectionGroups.get(key).push(conn);
        });

        // Assign varying curvatures
        connectionGroups.forEach(connections => {
            if (connections.length === 1) {
                connections[0].curvature = 0.2;
            } else {
                connections.forEach((conn, i) => {
                    conn.curvature = 0.1 + (i / (connections.length - 1)) * 0.5;
                });
            }
        });

        // Load and draw US map
        d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json").then(us => {
            console.log("Map data loaded successfully");
            
            // Draw states
            g.append("g")
                .selectAll("path")
                .data(topojson.feature(us, us.objects.states).features)
                .enter().append("path")
                .attr("d", path)
                .attr("fill", "#f0f0f0")
                .attr("stroke", "#ccc")
                .attr("stroke-width", 1);

            // Create tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "geo-tooltip")
                .style("position", "absolute")
                .style("padding", "10px")
                .style("background", "rgba(0, 0, 0, 0.9)")
                .style("color", "white")
                .style("border-radius", "6px")
                .style("font-size", "12px")
                .style("pointer-events", "none")
                .style("opacity", 0)
                .style("max-width", "300px")
                .style("z-index", "1000");

            // Draw connections
            if (validConnections.length > 0) {
                g.append("g")
                    .attr("class", "connections")
                    .selectAll("path")
                    .data(validConnections)
                    .enter()
                    .append("path")
                    .attr("d", d => createCurvedPath(
                        cityCoordinates[d.sourceCity], 
                        cityCoordinates[d.targetCity], 
                        d.curvature
                    ))
                    .attr("stroke", d => d.color)
                    .attr("stroke-width", d => Math.max(2, Math.min(6, d.similarity * 10)))
                    .attr("stroke-opacity", 0.7)
                    .attr("fill", "none")
                    .style("cursor", "pointer")
                    .on("mouseover", (event, d) => {
                        d3.select(event.target)
                            .attr("stroke-width", Math.max(4, Math.min(8, d.similarity * 12)))
                            .attr("stroke-opacity", 1);
                        
                        tooltip.transition().duration(200).style("opacity", .95);
                        tooltip.html(`
                            <div style="font-weight: bold; margin-bottom: 5px;">
                                ${d.sourceCity} â†” ${d.targetCity}
                             </div>
                            <div><strong>Source:</strong> ${d.sourcePublication} (Page ${d.sourcePageId})</div>
                            <div><strong>Target:</strong> ${d.targetPublication} (Page ${d.targetPageId})</div>
                            <div><strong>Reuse Type:</strong> ${d.reuse_type.replace('_', ' ')}</div>
                            <div><strong>Similarity:</strong> ${(d.similarity * 100).toFixed(1)}%</div>
                            <div><strong>Source Date:</strong> ${d.sourceDate}</div>
                            <div><strong>Target Date:</strong> ${d.targetDate}</div>
                            <div style="color: #ffd700;">Cross-publication reuse</div>
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                    })
                    .on("mouseout", (event, d) => {
                        d3.select(event.target)
                            .attr("stroke-width", Math.max(2, Math.min(6, d.similarity * 10)))
                            .attr("stroke-opacity", 0.7);
                        
                        tooltip.transition().duration(300).style("opacity", 0);
                    });
            }

            // Draw cities
            g.append("g")
                .attr("class", "cities")
                .selectAll("circle")
                .data(validCities)
                .enter()
                .append("circle")
                .attr("cx", d => projection([d.coords.lon, d.coords.lat])[0])
                .attr("cy", d => projection([d.coords.lon, d.coords.lat])[1])
                .attr("r", d => Math.max(8, Math.min(25, d.pageCount * 2)))
                .attr("fill", d => {
                    const pubs = Array.from(d.publications);
                    return publicationColorManager.getColor(pubs[0], pubs[0]);
                })
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.9)
                .style("cursor", "pointer")
                .on("mouseover", (event, d) => {
                    const publicationsList = Array.from(d.publications).join(", ");
                    tooltip.transition().duration(200).style("opacity", .9);
                    tooltip.html(`
                        <div style="font-weight: bold; margin-bottom: 5px;">${d.location}</div>
                        <div><strong>Pages:</strong> ${d.pageCount}</div>
                        <div><strong>Cross-pub Connections:</strong> ${d.connections}</div>
                        <div><strong>Publications:</strong> ${publicationsList}</div>
                    `)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(300).style("opacity", 0);
                });

            // Add city labels
            g.append("g")
                .attr("class", "city-labels")
                .selectAll("text")
                .data(validCities)
                .enter()
                .append("text")
                .attr("x", d => projection([d.coords.lon, d.coords.lat])[0])
                .attr("y", d => projection([d.coords.lon, d.coords.lat])[1] - Math.max(10, Math.min(27, d.pageCount * 2)))
                .attr("text-anchor", "middle")
                .style("font-size", "11px")
                .style("font-weight", "bold")
                .style("fill", "#333")
                .style("text-shadow", "1px 1px 2px white, -1px -1px 2px white, 1px -1px 2px white, -1px 1px 2px white")
                .text(d => d.location.split(',')[0])
                .style("pointer-events", "none");

            // Store svg reference for controls
            geoSvg = svg;

            console.log(`Geographic Network complete: ${validCities.length} cities, ${validConnections.length} cross-publication connections`);

        }).catch(error => {
            console.error("Error loading map data:", error);
            d3.select("#geographic-network").append("div")
                .style("padding", "20px")
                .style("text-align", "center")
                .style("color", "red")
                .text("Error loading map data. Check console for details.");
        });
    }

    function setupControls() {
        console.log('Setting up geographic controls...');
        
        // Similarity slider
        const geoSlider = document.getElementById("geo-similarity-slider");
        const geoValue = document.getElementById("geo-similarity-value");
        
        if (geoSlider && geoValue) {
            geoSlider.addEventListener("input", function() {
                geoValue.textContent = (+this.value).toFixed(2);
            });
        }

        // Filter dropdowns
        const reuseTypeFilter = document.getElementById("reuse-type-filter");
        const publicationFilter = document.getElementById("publication-filter");
        
        if (reuseTypeFilter) {
            reuseTypeFilter.addEventListener("change", updateGeoNetwork);
        }
        
        if (publicationFilter) {
            publicationFilter.addEventListener("change", updateGeoNetwork);
        }

        // Update button
        const updateButton = document.getElementById("refresh-geo-map");
        if (updateButton) {
            updateButton.addEventListener("click", updateGeoNetwork);
        }

        // Reset zoom button
        const resetButton = document.getElementById("reset-map-zoom");
        if (resetButton) {
            resetButton.addEventListener("click", function() {
                if (geoSvg && geoZoom) {
                    geoSvg.transition().duration(750).call(
                        geoZoom.transform,
                        d3.zoomIdentity
                    );
                }
            });
        }
        
        console.log('Geographic controls set up successfully');
    }

    function updateGeoNetwork() {
        if (!globalReuseData || !globalMetadata) return;
        const threshold = parseFloat(document.getElementById('geo-similarity-slider').value);
        createGeographicNetwork(globalReuseData, globalMetadata, threshold);
    }

    function populatePublicationFilter(metadata) {
        const publications = [...new Set(metadata.map(d => d.publication_name))].filter(Boolean).sort();
        
        const publicationFilter = document.getElementById('publication-filter');
        publicationFilter.innerHTML = '<option value="all">All Publications</option>';
        
        publications.forEach(pub => {
            const option = document.createElement('option');
            option.value = pub;
            option.textContent = pub;
            publicationFilter.appendChild(option);
        });

        // Also register colors for each publication
        publications.forEach(pub => {
            publicationColorManager.getColor(pub, pub);
        });
    }

    // Replace the entire "Main data loading" section at the bottom with this:
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, starting direct CSV data load...');
        
        // Load CSV files directly
        Promise.all([
            d3.csv("{{ url_for('static', filename='data/text_reuse_ngrams_windowed_parallel_filtered.csv') }}"),
            d3.csv("{{ url_for('static', filename='data/zinepage_metadata.csv') }}"),
            d3.csv("{{ url_for('static', filename='data/zinepub_metadata.csv') }}")
        ]).then(function([reuseData, pageMetadata, pubMetadata]) {
            console.log('Raw CSV data loaded:');
            console.log('- Reuse data:', reuseData.length, 'records');
            console.log('- Page metadata:', pageMetadata.length, 'records');
            console.log('- Publication metadata:', pubMetadata.length, 'records');
            
            if (!reuseData || reuseData.length === 0) {
                throw new Error('No reuse data found in CSV');
            }
            
            // Process the data
            // 1. Create publication lookup from page metadata
            const pubLookup = {};
            pageMetadata.forEach(page => {
                pubLookup[page.page_id] = page.publication_name;
            });
            
            // 2. Process reuse data and add publication names
            const processedReuseData = reuseData.map(d => {
                // Get publication names from page metadata
                const sourcePub = pubLookup[d.source_page_id] || 'Unknown';
                const targetPub = pubLookup[d.target_page_id] || 'Unknown';
                
                // Determine reuse type based on similarity score
                const similarity = +d.combined_similarity;
                let reuseType;
                if (similarity < 0.3) {
                    reuseType = 'minimal_reuse';
                } else if (similarity < 0.7) {
                    reuseType = 'partial_reuse';
                } else {
                    reuseType = 'moderate_reuse';
                }
                
                return {
                    source_page_id: d.source_page_id,
                    target_page_id: d.target_page_id,
                    combined_similarity: +d.combined_similarity,
                    ngram_similarity: +(d.ngram_similarity || 0),
                    shingle_similarity: +(d.shingle_similarity || 0),
                    source_publication: sourcePub,
                    target_publication: targetPub,
                    source_date: d.source_date || '',
                    target_date: d.target_date || '',
                    reuse_type: reuseType,
                    shared_content: d.shared_content || ''
                };
            });
            
            // Replace the combinedMetadata creation section with this:
            const combinedMetadata = pageMetadata.map(page => {
                // Find matching publication metadata by publication_name
                const pubData = pubMetadata.find(pub => pub.publication_name === page.publication_name) || {};
                
                return {
                    page_id: page.page_id,
                    publication_name: page.publication_name,
                    volume: page.volume || '',
                    number: page.number || '',
                    page_number: page.page_number || '',
                    organization: pubData.organization || '',
                    location: pubData.location || '', // Location comes from publication metadata
                    region: pubData.region || '',
                    notes: pubData.notes || ''
                };
            });
            
            // Updated debugging to verify the fix:
            console.log('=== LOCATION DEBUGGING (FIXED) ===');
            console.log('Sample combined metadata with locations:', 
                combinedMetadata.filter(p => p.location).slice(0, 5).map(p => ({ 
                    page_id: p.page_id, 
                    location: p.location, 
                    pub: p.publication_name 
                }))
            );
            console.log('Total pages with locations after combining:', 
                combinedMetadata.filter(p => p.location).length);
            
            // Check if publication names match between datasets
            const pagePublications = [...new Set(pageMetadata.map(p => p.publication_name))];
            const pubPublications = [...new Set(pubMetadata.map(p => p.publication_name))];
            console.log('Publication names in page metadata:', pagePublications);
            console.log('Publication names in pub metadata:', pubPublications);
            
            const matchingPubs = pagePublications.filter(pub => pubPublications.includes(pub));
            const missingPubs = pagePublications.filter(pub => !pubPublications.includes(pub));
            console.log('Matching publications:', matchingPubs.length);
            console.log('Missing from pub metadata:', missingPubs);
            console.log('=== END DEBUGGING ===');
            
            // Store globally for use by other functions
            globalReuseData = processedReuseData;
            globalMetadata = combinedMetadata;
            
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';
            document.getElementById('stats').style.display = 'flex';
            
            // Populate filters
            populatePublicationFilter(combinedMetadata);
            
            // Initialize the network
            createGeographicNetwork(processedReuseData, combinedMetadata);
            setupControls();
            
            // Update the legend
            publicationColorManager.populateLegend('publication-legend');

        }).catch(function(error) {
            console.error("Error loading CSV data:", error);
            document.getElementById('loading').innerHTML = 
                `<div style="color: red; padding: 20px; background: #ffebee; border: 1px solid #f44336; border-radius: 5px;">
                    <h3>Error Loading Data</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <p>Make sure these CSV files exist in your static/data/ folder:</p>
                    <ul>
                        <li>text_reuse_ngrams_windowed_parallel_filtered.csv</li>
                        <li>zinepage_metadata.csv</li>
                        <li>zinepub_metadata.csv</li>
                    </ul>
                </div>`;
        });
    });
</script>
{% endblock %}